\documentclass[12pt,pdftex,a4paper]{article}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{ulem}
\usepackage{bbm}
\usepackage{array}
\usepackage{marvosym}
\usepackage{color}
\usepackage{hhline}
\usepackage[pdftex]{graphicx}
\usepackage{listings}
\lstset{language=Python,basicstyle=\footnotesize}
\usepackage{pdfpages}
\usepackage{booktabs}
\PassOptionsToPackage{hyphens}{url}
\usepackage{hyperref}
\usepackage{extarrows}
\usepackage{rotating}
\newcommand\tab[1][1cm]{\hspace*{#1}}

\title{ Grundlagen Informationsicherheit und Datensicherheit,\\ Blatt 6}
\author{Lukas Baur, 3131138\\
	Felix Bühler, 2973410\\
	Marco Hildenbrand, 3137242}


\begin{document}
\maketitle
\pagebreak
\section*{Problem 1: Protocol for Mutual Authentication}
Reflection attack:\\
Eine Person, die $ N_B $ korrekt entschlüsselt hat, ist jemand, der den KEY kennt (Alice). Allerdings kennt Bob selbst den KEY auch! Der Angreifer kann also die gesendeten Nachrichten auzeichnen und später nochmal senden und sich damit als Alice ausgeben.
\\~\\
E = Evil (= Attacker)
\begin{enumerate}
	\item Verbindung 1: A $ \rightarrow $ B \tab : $ enc_s^k(N_A) $
	\item Verbindung 1: B $ \rightarrow $ A \tab : $ enc_s^k(N_B), N_A $
	\item Verbindung 1: A $ \rightarrow $ B \tab : $ N_B $
	\setlength{\itemsep}{20pt}
	\item Verbindung 2: E $ \rightarrow $ A \tab : $ enc_s^k(N_B) $
	\setlength{\itemsep}{5pt}
	\item Verbindung 2: A $ \rightarrow $ E \tab : $ enc_s^k(N_A'), N_B $
	\item Verbindung 3: E $ \rightarrow $ A \tab : $ enc_s^k(N_A') $
	\item Verbindung 3: A $ \rightarrow $ E \tab : $ enc_s^k(N_A''), N_A' $
	\item Verbindung 2: A $ \rightarrow $ E \tab : $ N_A' $
\end{enumerate}

\pagebreak
\section*{Problem 2: Kerberos}

Im folgenden gehen wir von folgender Anfangssituation aus:\\
\begin{tabular}{|c|c|c|c|c|}
C &  $\xlongrightarrow{cert_{C}, sig_{\hat{k}_{C}}(t_{C}, n_{2}), C, TGS, n_{1}}$  & E & $\xlongrightarrow{cert_{E}, sig_{\hat{k}_{E}}(t_{C}, n_{2}), E, TGS, n_{1}}$   & KAS \\ 
\end{tabular} 

\subsection*{(a)}
Die Vorgestellte Idee stellt \textbf{keine} sichere Lösung dar: \\\\
Bei einem MitM sendet der Server unter anderem $enc_{k}^{s}(AK, n_{1}, t_{KAS}, TGS, E)$ zurück. Diesen Teil kann E enschlüsseln ( mit dem Key $k$, den er auch bekommt) und sendet dann die substituierte Nachricht zurück:\\
\begin{tabular}{|c|c|c|}
E & 
$\xlongleftarrow{enc_{k_{E}}^{a}(cert_{KAS}, sig_{\hat{k}_{KAS}}(k,n_{2})), E , TGT, enc_{k}^{s}(AK, n_{1}, t_{KAS}, TGS, E) } $
 & KAS 
\end{tabular} 
\\\\\\
\begin{tabular}{|c|c|c|}
C & 

$\xlongleftarrow{enc_{k_{C}}^{a}(cert_{KAS}, sig_{\hat{k}_{KAS}}(k,n_{2})), C , TGT, enc_{k}^{s}(AK, n_{1}, t_{KAS}, TGS, C) } $ & E 
\end{tabular} 

\subsection*{(b)}
Die Vorgestellte Idee stellt eine \textbf{sichere Lösung} dar: \\\\
Der Name, für den der TGT bereitgestellt wird, wird von KAS-Server mit dessen privaten Schlüssels verschlüsselt. Diese Signatur kann E nicht fälschen.
\subsection*{(c)}
Die Vorgestellte Idee stellt \textbf{keine} sichere Lösung dar: \\\\
Die Nachricht, in der der Name eingetragen und verschlüsselt wurde, lässt sich von E entschlüsseln, da er den privaten Schlüssel hierfür besitzt. Ein Substituieren ist dann problemlos möglich.\\
\begin{tabular}{|c|c|c|}
E & 
$\xlongleftarrow{enc_{k_{E}}^{a}(E, cert_{KAS}, sig_{\hat{k}_{KAS}}(k,n_{2})), E , TGT, enc_{k}^{s}(AK, n_{1}, t_{KAS}, TGS) } $
 & KAS 
\end{tabular} 
\\\\\\
\begin{tabular}{|c|c|c|}
C & 

$\xlongleftarrow{enc_{k_{C}}^{a}(C, cert_{KAS}, sig_{\hat{k}_{KAS}}(k,n_{2})), C , TGT, enc_{k}^{s}(AK, n_{1}, t_{KAS}, TGS) } $ & E 
\end{tabular} 


\begin{sidewaystable}[ph!]

\section*{Problem 3: TLS and Randomness}
	\begin{tabular}{|c|c|c|c|c|}
		C &  $\xlongrightarrow{\text{(1) Client hello:} TLSVersion_{C},  CipherSuites_{C}, N_{C}}$  & E &  $\xlongrightarrow{\text{(1) Client hello:} TLSVersion_{C},  CipherSuites_{C}, N_{C}}$   & S \\ 
		
		C &  $\xlongleftarrow{\text{(2) Server hello:} TLSVersion_{S},  ChosenCipherSuites_{S}, N_{S}, CERT_{E}(k_{E})}$ & E &  $\xlongleftarrow{\text{(2) Server hello:} TLSVersion_{S},  ChosenCipherSuites_{S}, N_{S}, CERT_{S}(k_{S})}$ & S \\ 
		
		C &  $\xlongrightarrow{\text{(3)Client Key Exchange: } enc^{a}_{k_{E}}(PMS)}$  & E &  $\xlongrightarrow{\text{(3)Client Key Exchange: } enc^{a}_{k_{S}}(PMS)}$  & S \\ 
		
		C &  $\xlongrightarrow{\text{(4)Client Finished: } enc_{k}^{auth}(hash(MS, TranscriptOfHandshake_{CE}))}$  & E &  $\xlongrightarrow{\text{(4)Client Finished: } enc_{k}^{auth}(hash(MS, TranscriptOfHandshake_{ES}))}$  & S \\ 
		
		C &  $\xlongleftarrow{\text{(5)Server Finished: } enc_{k}^{auth}(hash(MS, TranscriptOfHandshake_{EC}))}$ & E &  $\xlongleftarrow{\text{(5)Server Finished: } enc_{k}^{auth}(hash(MS, TranscriptOfHandshake_{SE}))}$ & S \\ 
		& • &  & • &  \\ 
		& • &  & • &  \\ 
		& • &  & • &  \\ 
		C & \textit{Session beendet} & E & \textit{Session beendet} & S \\ 
	\end{tabular} 
	\\\\
	\\
	\begin{tabular}{|c|c|c|c|c|}
		C &  $\xlongrightarrow{\text{(1) Client hello:} TLSVersion_{C},  CipherSuites_{C}, N_{C}}$  & E &  $\xlongrightarrow{\text{(1) Client hello:} TLSVersion_{C},  CipherSuites_{C}, N_{C}}$   & S \\ 
		
		C &  $\xlongleftarrow{\text{(2) Server hello:} TLSVersion_{S},  ChosenCipherSuites_{S}, N_{S}, CERT_{C}(k_{S})}$ & E &  $\xlongleftarrow{\text{(2) Server hello:} TLSVersion_{S},  ChosenCipherSuites_{S}, N_{S}, CERT_{C}(k_{S})}$ & S \\ 
		
		C &  $\xlongrightarrow{\text{(3)Client Key Exchange: } enc^{a}_{k_{S}}(PMS)}$  & E &  $\xlongrightarrow{\text{(3)Client Key Exchange: } enc^{a}_{k_{S}}(PMS')}$  & S \\ 
		
		C &  $\xlongrightarrow{\text{(4)Client Finished: } enc_{k}^{auth}(hash(MS, TranscriptOfHandshake))}$  & E &  $\xlongrightarrow{\text{(4)Client Finished: } enc_{k}^{auth}(hash(MS, TranscriptOfHandshake))}$  & S \\ 
		
		C &  $\xlongrightarrow{\text{(5)Server Finished: } enc_{k}^{auth}(hash(MS, TranscriptOfHandshake'))}$ & E &  $\xlongrightarrow{\text{(5)Server Finished: } enc_{k}^{auth}(hash(MS, TranscriptOfHandshake'))}$ & S \\ 
		C & • & E & • & S \\ 
		C & • & E & • & S \\ 
		C & • & E & • & S \\ 
		C & \textit{Session beendet} & E & \textit{Session beendet} & S \\ 
	\end{tabular} 
\end{sidewaystable}
\clearpage

\section*{Problem 4: Attack on IKEv1 Main Mode}
Reflection attack:

Der Angriff ist eine einfache Reflexion, die erfordert, dass ein Initiator seine eigene Identität als Gleichrangigen-Peer akzeptiert. In diesem Fall werden die Authentifizierer in dem Protokoll gleich und der Gegner sendet einfach alle Nachrichten, die von dem Initiator kommen, unverändert an sie zurück. In diesem Fall schlägt die schwache Vereinbarung fehl, da kein Agent die Responder-Rolle ausführt. Die Geheimhaltung des Schlüssels ist weiterhin gewährleistet. Wenn eine Selbstkommunikation nicht möglich ist, ist der aufgezeigte Angriff nicht mehr möglich.

\end{document}
